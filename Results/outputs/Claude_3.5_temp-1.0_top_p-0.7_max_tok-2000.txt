# VERSION_1.2.md

# Brush Language - Version 1.2.0 Release Notes

Released: March 24, 2025

## Overview

Brush 1.2.0 represents a significant milestone in the language's evolution, focusing on performance optimizations, enhanced type safety, and developer experience improvements. This release includes substantial enhancements to the compiler infrastructure, runtime performance, and standard library capabilities.

We're excited to introduce the new asynchronous programming model, which provides first-class support for concurrent operations without the complexity traditionally associated with thread management. Version 1.2 also brings notable improvements to the type system, making generic programming more intuitive while maintaining Brush's commitment to strong type safety.

## Highlights

### New Asynchronous Programming Model

Brush 1.2 introduces a comprehensive async/await paradigm, allowing developers to write non-blocking code with a synchronous-like syntax. The runtime scheduler intelligently manages task execution across available threads, optimizing for both I/O-bound and CPU-bound workloads. This implementation leverages a zero-copy promise architecture that minimizes overhead compared to traditional callback approaches.

```brush
async fn fetch_data(url: String) -> Result<Data, Error> {
    let response = await http.get(url)?;
    return Data.from_json(response.body);
}
```

### Enhanced Type Inference System

Version 1.2 delivers significant improvements to type inference for generic functions, reducing the need for explicit type annotations by up to 80% in complex scenarios. The compiler now performs bidirectional type checking during constraint resolution, allowing it to infer complex generic types from context. This enhancement is particularly valuable when working with higher-order functions, making functional programming patterns more concise and readable.

### Pattern Matching Enhancements

Pattern matching has been expanded with support for nested destructuring, guards, and binding patterns. The compiler now optimizes pattern matching into efficient jump tables when appropriate, resulting in performance comparable to hand-written conditional logic. These improvements make pattern matching a more powerful tool for expressing complex control flow with clear, declarative syntax.

```brush
match message {
    Message.Text(content) if content.starts_with("/command") => {
        handle_command(content.substring(9))
    },
    Message.Image{size: s, data: d} if s > MAX_SIZE => {
        resize_and_process(d, MAX_SIZE)
    },
    msg @ Message.Binary{..} => {
        log.warn("Received binary message: {}", msg);
        process_binary(msg)
    },
    _ => default_handler()
}
```

### Standard Library Expansion

The standard library has been significantly expanded with over 40 new functions and 12 new modules. Key additions include comprehensive date/time manipulation (stdlib/time), enhanced file system operations (stdlib/fs), and cryptographic primitives (stdlib/crypto). All new APIs follow the established Brush design principles of being strongly typed, memory-safe, and performance-oriented.

### Interactive Debugger

Brush 1.2 introduces an integrated debugging experience with the new `brush debug` command. The interactive debugger supports breakpoints, variable inspection, conditional breaks, and step-through execution. The debugger maintains full type information at runtime, enabling rich introspection capabilities without performance penalties in release builds.

## Breaking Changes

⚠️ **String Encoding Change**: The default string encoding has changed from UTF-8 to UTF-16 for improved cross-platform compatibility. Code that relies on byte-level string operations may need adjustment. See migration guide in docs/migration/1.1-to-1.2.md.

⚠️ **Module Resolution**: The module resolution algorithm has been updated to prioritize local modules over global ones when both exist with the same name. This change helps prevent dependency conflicts but may affect projects with non-standard directory structures.

## Bug Fixes

Version 1.2 addresses 32 bugs reported since the 1.1 release, including several critical issues affecting the compiler, runtime, and standard library. Notable fixes include resolving memory leaks in the garbage collector, eliminating parser ambiguities with nested expressions, and correcting type inference issues with higher-kinded types. For a complete list of fixes, see CHANGELOG_1.2.md.

## Performance Improvements

Significant performance optimizations have been implemented throughout the Brush ecosystem:

- Compiler throughput improved by 28% for large projects
- Runtime memory usage reduced by 35% through optimized object representation
- String operations are now 40-65% faster due to improved internal representation
- Standard library collection operations show 15-30% performance gains
- Binary size reduced by 22% through improved dead code elimination

## Deprecation Notices

The following features are deprecated in Brush 1.2 and will be removed in version 1.3:

- The `@unsafe` attribute for bypassing memory safety checks (use the new `unsafe` block syntax instead)
- Legacy callback-style asynchronous APIs (migrate to the new async/await paradigm)
- The `brush.util.StringBuffer` class (use `StringBuilder` from stdlib/text instead)
- Direct access to memory via `ptr.offset()` (use the safer `ptr.advance()` method)

## Installation & Upgrade

Brush 1.2 is compatible with 1.1.x modules but requires recompilation for optimal performance. Upgrade using the package manager:

```
brush package upgrade
```

Developers upgrading from 1.1.x should note that while most code will continue to work without changes, the string encoding modification may affect applications with specific string handling requirements. The compiler will emit warnings for most deprecated feature usage.

## Dependencies

- Requires LLVM 16.0+ for backend optimizations
- Compatible with GCC 12+ and Clang 15+
- Runtime footprint reduced from 8.2MB to 5.6MB
- Supports Windows 10/11, macOS 12+, and Linux (glibc 2.31+)

For a complete list of changes and detailed migration guidance, please refer to the full documentation at https://docs.brushlang.org/1.2/

---

# CHANGELOG_1.2.md

## [1.2.0] - 2025-03-24

### Added

- Added async/await syntax for non-blocking concurrent programming. New runtime scheduler efficiently manages task execution across available threads. (#1840)

- Implemented interactive debugger with breakpoints, variable inspection, and step-through execution. Accessible via the new `brush debug` command. [BRH-302]

- Added comprehensive date/time manipulation module (stdlib/time) with timezone support, formatting, and parsing capabilities. Thanks to Mike Torres for the initial implementation.

- Introduced pattern matching enhancements: nested destructuring, guards, and binding patterns. Compiler now optimizes patterns into efficient jump tables when possible. (#1872)

- Add new crypto primitives in stdlib/crypto including AES, RSA, and hash functions (SHA-256, SHA-3, Blake3). Fixed by Sarah Chen <s.chen@brushlang.org>

### Changed

- Update string encoding from UTF-8 to UTF-16 for improved cross-platform compatibility. ⚠️ This is a breaking change for code relying on byte-level string operations. (#1901)

- Changed module resolution to prioritize local modules over global ones when both exist with the same name. This helps prevent dependency conflicts. [BRH-329]

- Updated documentation for async/await syntax, previous examples was using deprecated callback style. (#2023)

- Refactored error reporting system to provide more context in stack traces and clearer error messages. Error now includes source code snippets and suggested fixes for common issues. (fixes #1925)

### Fixed

- Fixed compiler crash when using nested lambda expressions with closure capture. The issue occurred in `eval_context()` when scope resolution failed for shadowed variables. (fixes #1847)

- Resolved SEGFAULT in garbage collector during concurrent object allocation at brush.runtime.gc_collect:142. Reported by Emma Rodriguez <e.rodriguez@techcorp.io>

- Fix memory leak in the standard library's HashMap implementation when keys with identical hash codes were repeatedly added and removed. (ERR_INVALID_TOKEN)

- Fixed type inference regression with higher-kinded types that caused E0308 errors in valid code. The issue was in the constraint solver's unification algorithm. Reported by John Smith <jsmith@email.com>

- Patched parser ambiguity with nested expressions containing both lambda and ternary operators. Parser now correctly prioritizes according to the language specification. (#1952)

### Performance

- Improved compiler throughput by 28% for large projects through parallelized type checking and optimized AST traversal. [BRH-